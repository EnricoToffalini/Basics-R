---
title: "Basics of Programming: Conditional Statements and Iterations"
author: "Enrico Toffalini"
include-in-header: ../assets/slidesheader.html
format:
  revealjs:
    code-line-numbers: false
    css: custom.css
    theme: default
    slide-number: c/t
    self-contained: false
    code-fold: false
    code-summary: "Show code"
    code-overflow: wrap
    title-slide-attributes: 
     data-background-image: "figures/psicostatLogo.png"
     data-background-size: "contain"
     data-background-opacity: "0.15"
execute:
  echo: true
  output: true
---
## What are data structures

<div style="font-size:46px;">
Data structures, like **vectors**, **matrices**, **dataframes**, **lists**, are fundamental tools that allow you to **organize and store complex information**, so that they can be easily **processes by functions** (e.g., `lm()` function to fit a linear model using variables stored in a dataframe)

Most operations you will perform in R (e.g., *processing data*, *fitting models*, *plotting outputs*) are performed on these data structures 
</div>

<!-- --------------------------------------------------------------------- -->
## Vectors

Simple one-dimensional structures that store data of different types

<div style="text-align: center;">
  <img src="figures/vectorBase.png"/>
</div>

Here is an actual **example** (of a *numerical* vector):

<div style="text-align: center;">
  <img src="figures/vectorHours.png"/>
</div>

## Vectors

Vectors can easily be **created using the `c()`** base function:

<div class="large-code">
```{r}
Teachers = c("Pastore", "Kiesner", "Granziol", "Toffalini", "Calignano",
            "Epifania", "Bastianelli")

Hours = c(10, 15, 20, 10, 15, 5, 15, 5)
```

But be careful NOT to mix different types of data:

```{r}
Hours = c(10, 15, 20, 10, 15, "tbd", 15, 5)
Hours # everthing is forced to become a character!
```

instead, if needed, use `NA` (Not Available):

```{r}
Hours = c(10, 15, 20, 10, 15, NA, 15, 5)
Hours # remains a numerical vector, NA does not affect type
```
</div>

## Vectors

Select/extract elements with **INDEXING** using square brackets **`[]`**:

<div class="large-code">
```{r}
Hours = c(10, 15, 20, 10, 15, 5, 15, 5)
Hours[4] # a single element
Hours[5:7] # a range of elements
Hours[c(1,3,6)] # specific elements
```

Know the **length** of a vector using the `length()` function, and use it:
```{r}
length(Hours)
```

```{r}
Hours[length(Hours)] # use it to extract the last element
```
</div>

## Vectors

**Negative indexing**

You can use the *minus* sign **`-`** to select **all elements except some** from a vector. (This method is also applicable to dataframes)

<div class="large-code">
```{r}
Hours = c(10, 15, 20, 10, 15, 5, 15, 5)
Hours[-4] # ALL BUT a single element
Hours[-c(5:7)] # ALL BUT a range of elements
Hours[-c(1,3,6)] # ALL BUT specific elements
Hours[-length(Hours)] # ALL BUT the last element
```
</div>

## Vectors
#### Logical indexing

Often, you'll need to extract values from a vector based on specific *<b>logical</b>* conditions. Here's an example:
```{r}
Hours = c(10, 15, 20, 10, 15, 5, 15, 5)
Hours[Hours >= 15] # extract only values greater than or equal to 15
```

This is called *<b>logical indexing</b>* because you are selecting elements based on a logical vector (i.e., a sequence of `TRUE`, `FALSE`):
```{r}
Hours >= 15 # the logical vector actually inside the square brackets
```

Also, you can use a vector to extract values **from another vector**: 
```{r}
Teachers[Hours >= 15]
```

## Vectors
#### Operations

you can simultaneously apply an operation to a whole vector, like

```{r}
Hours = c(10, 15, 20, 10, 15, 5, 15, 5)
Hours / 5
```

Of course, this is useful when you want to save the result as a new vector:

```{r}
ECTS = Hours / 5
```

Similarly, you can apply functions to all elements of a vector: 

```{r}
sqrt(Hours) # computes square root of each element
log(Hours) # computes the natural logarithm of each element
```


## Vectors
#### Summary statistics

A whole vector may serve to compute summary statistics, for example using functions such as `mean()`, `sd()`, `median()`, `quantile()`, `max()`, `min()`:

```{r}
mean(Hours) # returns the average value (mean) of the vector
sd(Hours) # returns the Standard Deviation of the vector
median(Hours) # returns the median value of the vector
quantile(Hours, probs=c(.25, .75)) # returns desired quantiles
max(Hours) # returns largest value
min(Hours) # returns smallest value
```


## Vectors
#### Summary statistics - Managing missing (`NA`) values

<div style="large-code">
All of the previous summary statistics will **fail** if there is even a single `NA` value:
```{r}
Hours = c(10, 15, 20, 10, 15, NA, 15, 5)

mean(Hours) # a single NA value implies that the average is impossible to determine
```

```{r, error=T}
quantile(Hours, probs=c(.25, .75)) # quantile() will even return an Error
```

You can easily manage missing values by adding the **`na.rm=TRUE`** argument:
```{r}
mean(Hours, na.rm=TRUE) # NA values are ignored 
quantile(Hours, probs=c(.25, .75), na.rm=TRUE) # NA values are ignored 
```
</div>

## Vectors
#### Example: replacing `NA` with the average value

<div style="large-code">
Replacing a missing value with the average across valid values is risky, as it may alter many other summary statistics, but it is a good example for understanding different concepts seen so far:

```{r}
Hours = c(10, 15, 20, 10, 15, NA, 15, 5)

# compute the average value ignoring NAs, and put it wherever 
# there is a NA value in the vector
Hours[is.na(Hours)] = mean(Hours, na.rm=TRUE)

# now let's inspect the updated content of the vector
Hours

# by the way... na.rm=TRUE is no longer needed now, as NA is no longer there
mean(Hours)
```
</div>

<!-- --------------------------------------------------------------------- -->
## 
### A type of data structure you are already familiar with

<div style="text-align: center;">
  <img src="figures/Courses40Cycle.png"/>
</div>

## Dataframes

here is how I would import it in R (<a href="data/Courses40Cycle.xlsx" download>download here</a>), and display the first few rows:

```{r}
library(readxl)
df = data.frame(read_excel("data/Courses40Cycle.xlsx"))
head(df)
```

## Dataframes

In fact, **dataframes** are just collections (lists) of **vectors** of different types, all with the same length. Each column in a dataframe is a vector (a variable):

```{r}
df$Teacher
df$Hours
```

## Dataframes

The "**`$`**" (dollar) operator is essential to access variables in a dataframe:

<div style="text-align: center;">
  <img src="figures/previewDataframe.png"/>
</div>

## Dataframes

To know the names of all variables in a dataframe, use the `names()` function:
```{r}
names(df)
```

Use the `dim()` function to view the dimensions of a dataframe: 
```{r}
# first value is number of rows, second is number of columns (variables)
dim(df) 
```

Alternatively, you can use `nrow()` and `ncol()`:
```{r}
nrow(df) # number of rows
ncol(df) # number of columns
```

## Dataframes

As an exercise, let's check whether `ECTS` is actually always `Hours*5`

We may use many different, increasingly sophisticated, strategies: 
<div class="large-code">
```{r}
df$Hours / df$ECTS

(df$Hours / df$ECTS) == 5

sum((df$Hours / df$ECTS) == 5)

sum((df$Hours / df$ECTS) == 5) == nrow(df)

sum((df$Hours / df$ECTS) != 5)
```
</div>

## Dataframes

Variables in a dataframe can be manipulated like any other vector:
```{r}
log(df$Hours)
```

Also, new variables can easily be created and added at any time: 
```{r}
df$newVar = log(df$Hours)
names(df)

df$newVar
```


## Dataframes
#### Indexing elements in a dataframe

In addition to using the "**`$`**" (dollar) operator, you can directly access a variable of a dataframe using **indexing** with **square brackets** `[]`: 
```{r}
df[ , "Hours"]
```

Notice the comma "**`,`**" above.

Unlike vectors, dataframes must be indexed by **both row and column**. In the example above, weâ€™re specifying only the desired column (`"Hours"`), leaving the row index blank before the comma **`,`** This selects all rows for the column named `"Hours"`. Remember that blank index means "all". Importantly, the "**`,`**" must always be there when indexing dataframes! 

## Dataframes
#### Indexing elements in a dataframe - Examples

```{r}
df[ 1 , "Hours"]
df[ 1:5 , "Hours"]
df[ 1 , c("Teacher","Hours","TypeOfCourse")]
df[ 1:5 , c("Teacher","Hours","TypeOfCourse")]
df[ 1 , c(4, 5, 2)]
```

## Dataframes
#### Logical indexing

Just like for vectors, you can use a logical condition for indexing a dataframe.

Let's consider this logical condition:
```{r}
df$Teacher == "MASSIMILIANO PASTORE"
```

Let's use it to extract some dataframe rows:

```{r}
df[df$Teacher == "MASSIMILIANO PASTORE" , ] # some rows by condition , all columns
```

## Dataframes
#### Indexing elements in a dataframe - A summary

<div style="text-align: center;">
  <img src="figures/dataframeCourses.png"/>
</div>


## Dataframes
#### Subset

Base function **`subset()`** can also be used as an alternative to indexing

```{r}
subset(df, Teacher == "MASSIMILIANO PASTORE", select=c("Teacher","Hours","TypeOfCourse"))
df[df$Teacher == "MASSIMILIANO PASTORE" , c("Teacher","Hours","TypeOfCourse")]
```

However, indexing with **`[]`** is more "computationally focused", computationally faster (especially if working with large datasets), and more similar to programming in other languages (e.g., **Python**), so should probably be favoured by data scientists!


## Dataframes
#### Combine two dataframes using `rbind()`

Imagine you have two datasets collected by two students, each including different participants: 

```{r, echo=F}
df1 = data.frame(subjName = c("Julie","Tommy","Phil"),
                 age = c(12, 10, 10),
                 accuracy = c(.92, .78, .85))
df2 = data.frame(subjName = c("Amber","Max"),
                 age = c(9, 13),
                 accuracy = c(.87, .90))
```

```{r}
df1
df2
```

Our goal is to get one single dataset including all participant's data for the final analysis. Of course, you could combined these files manually outside R (e.g., in Excel). However, it's simpler and more efficient to do this directly in R using `rbind()`


## Dataframes
#### Combine two dataframes using `rbind()`

```{r}
dfTotal = rbind(df1, df2)

dfTotal
```

**Important**: for `rbind()` to work, the two to-be-combined dataframes must:

- have the **exact same number of columns**;

- the **column names must be identical** (remember that R is case-sensitive).


## Dataframes
#### Merge two dataframes using `merge()`

Another frequent case is having data collected from the **same participants** across **different dataframes**, and having to analyze all information together:

```{r, echo=F}
df1 = data.frame(subjName = c("Julie","Amber","Tommy","Phil"),
                 age = c(12, 9, 10, 10))
df2 = data.frame(subjName = c("Julie","Tommy","Phil","Amber"),
                 accuracy = c(.92, .78, .85, .87),
                 time = c(1203, 3302, 994, 1163))
```

```{r}
df1
df2
```

## Dataframes
#### Merge two dataframes using `merge()`

You can merge the two dataframes into a single, comprehensive dataframe: 

```{r}
dfTotal = merge(df1, df2, by="subjName")

dfTotal
```

**Important**: `merge()` will work even if some or even all values that should be used for merging do not match... but in that case part of or all data will be lost


<!-- --------------------------------------------------------------------- -->
